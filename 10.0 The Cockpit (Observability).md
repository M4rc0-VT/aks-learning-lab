# **Day 10: The Cockpit (Observability)** ğŸ“Š

### **Summary**

Right now, your cluster is a "Black Box." If the Nginx app crashes or the CPU spikes to 100%, you won't know until you manually run `kubectl` or someone complains. Today, we install the **"Eyes and Ears"** of your platform.

We are skipping the "Azure Native" tools (Azure Monitor) and going straight for the **Industry Standard** open-source stack that 90% of job descriptions ask for: **Prometheus** and **Grafana**.

### **The Agenda**

1. **The Stack:** Understand why we need two tools (Prometheus to "scrape" the data, Grafana to "visualize" it).
2. **Infrastructure as Code:** We won't just run a command. We will add this stack to your `main.tf` so it is managed by Terraform.
3. **Visualization:** We will log into a dashboard and actually see your Nginx pods consuming memory in real-time.

---

### **Step 1: Update Terraform (`main.tf`)** ğŸ—ï¸

We need to tell Terraform to install the "kube-prometheus-stack". This is a massive bundle that sets up Prometheus, Grafana, and all the alerts for us automatically.

1. Open your **`main.tf`** file in VS Code.
2. Scroll to the very bottom.
3. **Add this new resource block:**

```hcl
# 1. Create a namespace for monitoring tools
resource "kubernetes_namespace" "monitoring" {
  metadata {
    name = "monitoring"
  }
}

# 2. Install the Prometheus & Grafana Stack using Helm
resource "helm_release" "prometheus_stack" {
  name       = "prometheus-stack"
  repository = "https://prometheus-community.github.io/helm-charts"
  chart      = "kube-prometheus-stack"
  namespace  = kubernetes_namespace.monitoring.metadata[0].name

  # Expert Tip: This stack is HUGE. We increase the timeout so Terraform doesn't panic.
  timeout    = 600
  
  # We set "atomic" to true so if it fails, it cleans up after itself.
  atomic     = true 
}

```

### **Step 2: The Apply** ğŸš€

Since you already have the cluster running, Terraform will just add these new layers on top.

1. Open your terminal to `C:\k8s-lab\terraform`.
2. Run the command:
```powershell
terraform apply

```


3. Type `yes` when prompted.

**Note:** This is a big download (it installs about 50 different components). It might take **3 to 5 minutes** to finish.

---

# **Day 10: The Cockpit (Observability)** ğŸ“Š

**Goal:** Transform the cluster from a "Black Box" into a visible system. We need to see real-time metrics (CPU, Memory, Network) to verify our application's health and resource usage.

---

### **1. Architectural Decisions** ğŸ›ï¸

#### **Decision A: Metrics vs. Logs (Prometheus vs. EFK)**

We debated which observability stack to install first.

* **The Options:**
* **Prometheus & Grafana (Metrics):** Lightweight. Tracks *numbers* (CPU %, RAM usage). "The Car Dashboard."
* **EFK Stack (Logs):** Heavy. Tracks *text* (Error logs, stack traces). "The Black Box Recorder."


* **The Verdict:** We chose **Prometheus/Grafana**.
* *Reason 1:* **Hardware Limits.** The EFK stack (specifically Elasticsearch) is memory-hungry and often crashes small "Burstable" VMs (Standard_B2s) like ours.
* *Reason 2:* **Immediate Value.** Grafana provides instant visual feedback on cluster health.



#### **Decision B: FinOps Strategy (Hibernate vs. Destroy)** ğŸ’°

We changed our daily shutdown protocol to balance "Time vs. Money."

* **Old Strategy:** `terraform destroy`. Cost: $0. Time to rebuild: 15 mins.
* **New Strategy:** `az aks stop`. Cost: ~$0.50/night (Disks). Time to wake up: 2 mins.
* **Decision:** Use **Stop** during the week (Mon-Thu) to save time, and **Destroy** on weekends to save money.

---

### **2. Infrastructure Changes (Terraform)** ğŸ—ï¸

We updated `main.tf` to deploy the monitoring stack automatically.

* **New Resource:** Added `resource "helm_release" "prometheus_stack"` to install the `kube-prometheus-stack` chart (Community standard).
* **New Namespace:** Created a dedicated `monitoring` namespace using `kubernetes_namespace_v1`.

---

### **3. The Troubleshooting Log ("War Stories")** âš”ï¸

#### **Bug 1: The "Ghost of Localhost"** ğŸ‘»

* **Error:** `dial tcp [::1]:80: connectex: No connection... target machine actively refused it.`
* **Context:** Terraform failed to create the namespace.
* **Root Cause:** The `kubernetes` provider was unconfigured. It defaulted to looking for a cluster on `localhost` (your laptop) instead of connecting to Azure.
* **Fix:** We updated the `provider "kubernetes"` block in `main.tf` to explicitly use the AKS credentials:
```hcl
provider "kubernetes" {
  host = azurerm_kubernetes_cluster.aks.kube_config.0.host
  # ... (client certificate & key decoding)
}

```



#### **Bug 2: The Windows vs. Linux Language Barrier** ğŸªŸ

* **Error:** `The term 'base64' is not recognized...`
* **Context:** Trying to decode the Grafana admin password.
* **Root Cause:** The command `base64 --decode` is a Linux utility. We are running PowerShell on Windows.
* **Fix:** We used the "Cheat Code" (knowing the default password is `prom-operator`) or the "Kubernetes Native" decoder command (`kubectl ... -o jsonpath`).

---

### **4. Verification & Visualization** ğŸ§ª

#### **Accessing the Dashboard (Secure Tunnel)**

Since we did not expose Grafana to the public internet (Security Best Practice), we used Port Forwarding:

```powershell
kubectl port-forward svc/prometheus-stack-grafana -n monitoring 3000:80

```

#### **The Result**

* **URL:** `http://localhost:3000`
* **Dashboard:** `Kubernetes / Compute Resources / Namespace (Pods)`
* **Observation:** We verified that the **CPU Limit** line (orange dashed line at `0.1`) perfectly matched the `resources.limits.cpu: 100m` setting we defined in our Helm chart days ago. This proved the entire IaC chain (Terraform -> Helm -> Kubernetes -> Monitoring) is accurate.

---

### **5. End of Day Protocol** ğŸ›‘

Instead of destroying, we hibernated the cluster:

```powershell
az aks stop --name aks-terraform-lab --resource-group rg-terraform-lab

```

---

**Next Up (Day 11): Secrets Management.** We need to stop hardcoding passwords and start using a Vault. ğŸ”