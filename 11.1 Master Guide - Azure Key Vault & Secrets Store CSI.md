It is completely normal to feel that way. Today was technically the hardest day so far because we dealt with **Identity Management**‚Äîwhich is notoriously complex in the cloud.

Below is the **"Master Guide"** for Day 11. It is written so you can read it from top to bottom and rebuild this entire setup from scratch without me.

---

# **Day 11 Master Guide: Azure Key Vault & Secrets Store CSI** üîê

**The Goal:** Stop storing passwords in code or Kubernetes Secrets (ETCD). Instead, keep them in **Azure Key Vault** and strictly "lease" them to specific Pods in memory only.

---

### **Phase 1: The Infrastructure (Terraform)** üèóÔ∏è

We need to create the Vault and tell AKS it is allowed to install the "Secrets Driver" software.

**File:** `C:\k8s-lab\terraform\main.tf`

#### **Step 1.1: Add the Random String Generator**

**Why?** Azure Key Vault names must be globally unique (like a website URL). `kv-lab` is definitely taken. We generate a random suffix to avoid name collisions.

```hcl
resource "random_string" "random" {
  length  = 6   # Keep this short! KV names max out at 24 chars.
  special = false
  upper   = false
}

```

#### **Step 1.2: Enable the Add-on in AKS**

**Why?** This installs the "Secrets Store CSI Driver" software on your Kubernetes nodes. It acts as the courier between the Pod and the Vault.

*Find your existing `azurerm_kubernetes_cluster` block and add this inside:*

```hcl
  key_vault_secrets_provider {
    secret_rotation_enabled = true # If you change the password in Azure, update the Pod automatically.
  }

```

#### **Step 1.3: Create the Key Vault**

**Why?** This is the physical vault in Azure where the secrets live.

```hcl
data "azurerm_client_config" "current" {} # Needed to get your Tenant ID

resource "azurerm_key_vault" "vault" {
  name                        = "kv-learning-lab-${random_string.random.result}"
  location                    = azurerm_resource_group.aks_rg.location
  resource_group_name         = azurerm_resource_group.aks_rg.name
  enabled_for_disk_encryption = true
  tenant_id                   = data.azurerm_client_config.current.tenant_id
  soft_delete_retention_days  = 7
  purge_protection_enabled    = false
  sku_name                    = "standard"

  # Access Policy 1: Gives YOU (the Admin) permission to manage secrets
  access_policy {
    tenant_id = data.azurerm_client_config.current.tenant_id
    object_id = data.azurerm_client_config.current.object_id
    secret_permissions = ["Get", "List", "Set", "Delete", "Purge"]
  }
}

```

#### **Step 1.4: Grant Permission to the Cluster**

**Why?** Just because the CSI Driver is installed doesn't mean it has the keys to the vault. We must explicitly grant the **Add-on Identity** read access.

```hcl
resource "azurerm_key_vault_access_policy" "aks_addon_access" {
  key_vault_id = azurerm_key_vault.vault.id
  tenant_id    = data.azurerm_client_config.current.tenant_id
  
  # Crucial: We grant access to the specific identity of the Add-on, not the generic VM
  object_id    = azurerm_kubernetes_cluster.aks.key_vault_secrets_provider[0].secret_identity[0].object_id

  secret_permissions = ["Get", "List"]
}

```

**Action:** Run `terraform apply`.

---

### **Phase 2: The Secret Content (Azure CLI)** üí∞

Now that the vault exists, let's put something inside it.

**Step 2.1: Get the Vault Name**
Since we used a random string, we need to know the final name.

```powershell
az keyvault list --resource-group rg-terraform-lab --query "[].name" -o tsv
# Example Output: kv-learning-lab-ab12cd

```

**Step 2.2: Create the Secret**

```powershell
az keyvault secret set --vault-name <YOUR_KV_NAME> --name "ExampleSecret" --value "MySuperSecurePassword123!"

```

---

### **Phase 3: The Bridge (Kubernetes Configuration)** üåâ

This is the hardest part. We need to create a `SecretProviderClass` that maps the Azure Secret to the Cluster.

**Step 3.1: Gather IDs**
You need three specific IDs to fill out the YAML file.

1. **Key Vault Name:** (You got this in Step 2.1).
2. **Tenant ID:** `az account show --query tenantId -o tsv`
3. **Client ID (The Identity):** This is the critical one. We need the ID of the specific CSI Driver Add-on.
```powershell
az aks show -g rg-terraform-lab -n aks-terraform-lab --query "addonProfiles.azureKeyvaultSecretsProvider.identity.clientId" -o tsv

```



**Step 3.2: Create `secret-provider.yaml**`
**File:** `C:\k8s-lab\secret-provider.yaml`

```yaml
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: azure-kv-provider
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "true" 
    
    # CRITICAL: This tells the node exactly WHICH identity card to show the Vault
    userAssignedIdentityID: "<PASTE_YOUR_CLIENT_ID_HERE>" 
    
    keyvaultName: "<PASTE_YOUR_KV_NAME_HERE>"
    cloudName: ""
    objects:  |
      array:
        - |
          objectName: ExampleSecret
          objectType: secret
          objectVersion: ""
    tenantId: "<PASTE_YOUR_TENANT_ID_HERE>"

```

**Action:** `kubectl apply -f secret-provider.yaml`

---

### **Phase 4: The Consumer (The Pod)** üß™

Finally, we create a Pod that mounts this "Provider" as a volume.

**Step 4.1: Create `test-pod.yaml**`
**File:** `C:\k8s-lab\test-pod.yaml`

```yaml
kind: Pod
apiVersion: v1
metadata:
  name: secrets-test-pod
spec:
  containers:
    - name: test-container
      image: nginx
      volumeMounts:
      - name: secrets-store01-inline
        mountPath: "/mnt/secrets"
        readOnly: true
  volumes:
    - name: secrets-store01-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: "azure-kv-provider" # Must match metadata.name in Phase 3

```

**Action:** `kubectl apply -f test-pod.yaml`

---

### **Phase 5: Verification** ‚úÖ

**Step 5.1: Check Status**

```powershell
kubectl get pods

```

*Wait for "Running".*

**Step 5.2: Read the Secret**

```powershell
kubectl exec secrets-test-pod -- cat /mnt/secrets/ExampleSecret

```

*Expected Output:* `MySuperSecurePassword123!`

---

### **Summary of Troubleshooting (The "Why")** ‚ùì

**The "Multiple Identities" Error:**

* **Symptom:** Pod stuck in `ContainerCreating`. `kubectl describe` shows "Multiple user assigned identities exist".
* **Reason:** The Azure Node (VM) has its own identity (to talk to the Azure network) AND the CSI Add-on identity (to talk to the Vault).
* **Solution:** We added `userAssignedIdentityID` to the YAML to explicitly tell the driver: "Use the Add-on Identity, not the VM Identity."

**The "Name Too Long" Error:**

* **Reason:** Azure Key Vault names are limited to 24 characters.
* **Solution:** We shortened the `random_string` length to 6.

---

### **End of Day Protocol** üõë

Since this is a detailed log, don't forget the cleanup command:

```powershell
az aks stop --name aks-terraform-lab --resource-group rg-terraform-lab

```