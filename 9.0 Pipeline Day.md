This is the perfect way to solidify your knowledge. Writing down "War Stories" (what went wrong and how we fixed it) is actually more valuable than just writing down the "Happy Path."

Here is your **Day 9: The Pipeline** summary, formatted exactly for your documentation file. I have structured it to capture the *flow* of our session, including the architectural debates and the debugging battles.

---

# **Day 9: The Pipeline (CI/CD)** üöÄ

**Goal:** Automate the entire deployment process. We want to push code to GitHub and have a robot automatically build the Docker image, push it to ACR, and update the AKS cluster.

---

### **1. The Architecture Decision: GitHub vs. Azure DevOps** üèõÔ∏è

Before writing code, we discussed why we are using GitHub Actions instead of the traditional Azure DevOps (ADO).

* **The "Two Kings" Problem:** Microsoft owns both. ADO is the "Enterprise Classic," but GitHub is the "Future Platform."
* **Why GitHub Wins:**
* **Innovation:** All new MSFT features (Copilot, Advanced Security) come to GitHub first.
* **Community:** 99% of open-source tools (Helm, Terraform) are native to GitHub.
* **Talent:** GitHub Actions is the modern standard for Cloud Native engineers in 2025.



---

### **2. The "Wake Up" Protocol** üèóÔ∏è

Since we destroy our lab daily to save money, we started by rebuilding the hardware.

* **Command:** `terraform apply` inside `C:\k8s-lab\terraform`.
* **Issue:** We encountered a `no cached repo` error because the local Helm client forgot where to find the Nginx software.
* **Fix:**
```powershell
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

```


### **3: Create the GitHub Repository** üêô

We needed a place for the code to live in the cloud. So we:

1.  Logged in to [GitHub.com](https://github.com/).
2.  Clicked the **+** icon (top right) -\> **New repository**.
3.  Named it: **`aks-learning-lab`**.
4.  Visibility: **Public** (Easier for now) or **Private** (If you prefer).

-----

### **4: Connected Your Laptop** üíª

Then, link your local folder to this new cloud repo.
*(Run these commands inside your main lab folder `C:\k8s-lab` ‚Äî NOT inside the terraform folder)*

```powershell
cd C:\k8s-lab
git init
git add .
git commit -m "Day 8: Initial commit with Terraform and Helm"
git branch -M main
# Replace <YOUR_USERNAME> with your actual GitHub username
git remote add origin https://github.com/<YOUR_USERNAME>/aks-learning-lab.git
git push -u origin main
```
------------------------


---

### **5. Identity Management: The "Two Robots"** ü§ñ

This was the most complex part of the day. We had to distinguish between two different identities:

1. **Robot A (Managed Identity):** Created by Terraform. Used by **AKS** to pull images from ACR. (Automated).
2. **Robot B (Service Principal):** Created by Us. Used by **GitHub** to push images to ACR. (Manual).

#### **The "Lost Keys" Incident** üîê

* **Problem:** We ran `terraform destroy`, which deleted the Resource Group ("The Office"). While Robot B still existed, its access badge was for the *old* office.
* **The Fix:** We had to re-authorize the robot for the new Resource Group and update the GitHub Secret.
* **Command to Authorize:**
```powershell
# We used the --json-auth flag to get the full credentials needed for GitHub
az ad sp create-for-rbac --name "github-actions-robot" --role contributor --scopes /subscriptions/<SUB_ID>/resourceGroups/rg-terraform-lab --json-auth

```



---

### **6. The Pipeline Configuration (`deploy.yaml`)** üìù

We created the automation brain in `.github/workflows/deploy.yaml`.

#### **Bug 1: The "Ghost" Build** üëª

* **Error:** The pipeline failed at `docker build .`.
* **Reason:** We had Terraform code (`.tf`) and Helm charts (`.yaml`), but we never actually created the application source code!
* **Fix:** We created a simple `Dockerfile` and `index.html` in the root folder so the robot had something to package.

#### **Bug 2: The Language Barrier (Helm Variables)** üó£Ô∏è

* **Error:** The Helm Chart (custom-made) expected `acrDnsName` and `imageVersion`, but the Pipeline (generic) was sending `image.repository`. The chart ignored the pipeline and tried to use the old, hardcoded values.
* **Fix:** We updated the `helm upgrade` step in the pipeline to speak the Chart's language:
```yaml
helm upgrade --install my-release ./my-nginx-app \
  --set acrDnsName=${{ env.ACR_NAME }}.azurecr.io \
  --set imageVersion=${{ github.sha }} \
  --set imageName=my-nginx

```



---

### **7. The Final Verifications** ‚úÖ

#### **The "Missing IP" Panic** üïµÔ∏è‚Äç‚ôÇÔ∏è

* **Symptom:** The pipeline turned Green üü¢, but `kubectl get service` showed no External IP.
* **Reason:** We were looking in the `default` namespace (where the App lives). The Public IP belongs to the Ingress Controller, which lives in the `ingress-basic` namespace.
* **Solution:**
```powershell
kubectl get service -n ingress-basic

```


*Result:* We found the LoadBalancer IP, visited it in the browser, and saw the "Mission Accomplished" page.

---

### **8. The Final Pipeline Code** üíª

*For future reference, this is the working `deploy.yaml` that handles the JSON login and correct Helm variables:*

```yaml
name: Build and Deploy to AKS

on:
  push:
    branches: ["main"]
  workflow_dispatch: # Allows you to click a button to run it manually

env:
  ACR_NAME: "acrlearninglabz2kz6" # <--- UPDATE THIS with your actual ACR Name
  AKS_RESOURCE_GROUP: "rg-terraform-lab"
  AKS_CLUSTER_NAME: "aks-terraform-lab"

permissions:
  id-token: write # Required for the "Robot" login (OIDC)
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # 1. Checkout the code
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Login to Azure (The Digital Handshake)
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # 3. Login to ACR (The Vault)
      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      # 4. Build and Push Docker Image
      - name: Build and Push Image
        run: |
          cd k8s-lab
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/my-nginx:${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/my-nginx:${{ github.sha }}

      # 5. Get AKS Credentials
      - name: Get AKS Credentials
        run: az aks get-credentials --resource-group ${{ env.AKS_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }}

      # 6. Deploy with Helm
      - name: Deploy to AKS
        run: |
          cd k8s-lab
          helm upgrade --install my-release ./my-nginx-app \
            --set acrDnsName=${{ env.ACR_NAME }}.azurecr.io \
            --set imageVersion=${{ github.sha }} \
            --set imageName=my-nginx

```

---

### **Next Steps**

Now that the platform is automated, the next logical step is **Observability**. We need to install the "Security Cameras" (Logging and Monitoring) to see what is happening inside the cluster when we aren't looking.

---


## **Why GitHub and not Azure DevOps?** 

This is the "Million Dollar Question" in the Microsoft ecosystem right now. üí∞
If you ask this in a room of DevOps Engineers, you will start a very long debate.

Here is the "Senior Engineer" answer to why we (and much of the industry) are choosing GitHub over Azure DevOps (ADO), even for Azure-hosted projects.

### **1. The "Two Kings" Problem** üëë

Microsoft owns **both** platforms.

  * **Azure DevOps:** The "Classic Enterprise" tool. It is powerful, stable, and great for project management (Boards), but it feels a bit like "Legacy" software.
  * **GitHub:** The "Future" platform. Microsoft bought GitHub in 2018 for $7.5 billion. Since then, almost all their major innovation (AI Copilot, Advanced Security, Codespaces) has gone into GitHub, not Azure DevOps.

### **2. Why the Industry is Shifting to GitHub** üöÄ

Even big banks and enterprises are moving from ADO to GitHub for a few reasons:

  * **The "Center of Gravity":** 99% of the world's open-source code lives on GitHub. If you want to use the latest tools (like Helm charts or Terraform modules), they are native to GitHub. Azure DevOps often feels like an island.
  * **GitHub Actions:** The pipeline tool we will use today (Actions) is the modern standard. It is generally faster to set up and has a massive marketplace of community-built plugins compared to Azure Pipelines.
  * **Security:** GitHub's "Advanced Security" (scanning your code for secrets and vulnerabilities) is the gold standard, and Microsoft brings these features to GitHub *first*.

### **3. Why would a company stick with Azure DevOps?** üè¢

Your intuition is correct‚Äîmany companies *do* stay with ADO, usually for two reasons:

  * **Azure Boards:** The project management tool (Jira alternative) in ADO is still much better than GitHub Projects.
  * **Legacy:** Moving 5 years of pipelines from ADO to GitHub is expensive and risky.

**For us (The Learning Lab):**
We use **GitHub** because it is free, it is where the "Cloud Native" world lives, and learning **GitHub Actions** will make you more employable in 2025 than learning Azure Pipelines (Classic).

-----

### **3. The Trigger** üî´

Now that the Secret is safely stored in GitHub settings, it is safe to push this file. This "Push" will be the button that starts the engine.

Run these commands in your VS Code terminal:

```powershell
# 1. Stage the new workflow file
git add .github/workflows/deploy.yaml

# 2. Commit it (Stamp it)
git commit -m "Add CI/CD pipeline"

# 3. Push it (Send it to the cloud)
git push
```
