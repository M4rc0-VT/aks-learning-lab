We are entering the realm of **Security** today. Up until now, if our application needed a database password, we would likely just base64 encode it and shove it into a Kubernetes Secret. In the security world, we call that "hiding the key under the doormat." Anyone with access to the namespace can read it.

Today, we upgrade to a bank vault.

---

# **Day 11: The Fort Knox (Secrets Management)** ğŸ”

### **Summary**

We are going to stop managing secrets inside Kubernetes. Instead, we will use **Azure Key Vault (AKV)**â€”the industry standard for storing sensitive data in Azure. We will configure your cluster to "lease" secrets from the vault only when it needs them, using the **Secrets Store CSI Driver**.

### **The Agenda**

1. **The "Wake Up" Protocol:** We need to de-hibernate your cluster before we can touch it.
2. **Infrastructure (Terraform):**
* Create an **Azure Key Vault**.
* Update the **AKS Cluster** to install the "Secrets Store CSI Driver" (an add-on that lets AKS talk to the Vault).


3. **The Identity Link:** Grant your AKS cluster permission to read from the Vault (using Workload Identity or Managed Identity).
4. **The Test:** We will create a fake "Database Password" in Azure and watch it magically appear inside a Pod as a file.

---

### **Step 1: Wake Up the Beast** â˜•

Since we hibernated the cluster yesterday to save money, Terraform won't be able to make changes until it's running again.

Run this command while you grab your coffee (it takes ~2-3 minutes):

```powershell
az aks start --name aks-terraform-lab --resource-group rg-terraform-lab

```

---

### **Step 2: Terraform - Building the Vault** ğŸ—ï¸

While the cluster wakes up, let's write the code. We need to create the Key Vault resource.

1. Open `C:\k8s-lab\terraform\main.tf`.
2. Add this new block at the bottom (or near your networking stuff):

```hcl
# 1. Get current client config (to get your Tenant ID)
data "azurerm_client_config" "current" {}

# 2. Create the Key Vault
resource "azurerm_key_vault" "vault" {
  name                        = "kv-learning-lab-${random_string.random.result}" # Unique name
  location                    = azurerm_resource_group.rg.location
  resource_group_name         = azurerm_resource_group.rg.name
  enabled_for_disk_encryption = true
  tenant_id                   = data.azurerm_client_config.current.tenant_id
  soft_delete_retention_days  = 7
  purge_protection_enabled    = false

  sku_name = "standard"

  # Access Policy: Give YOU (the admin) full access so you can create secrets
  access_policy {
    tenant_id = data.azurerm_client_config.current.tenant_id
    object_id = data.azurerm_client_config.current.object_id

    secret_permissions = [
      "Get", "List", "Set", "Delete", "Purge"
    ]
  }
}

```

**Wait! Don't apply yet.** We need to update the Cluster to install the CSI Driver.

3. Find your existing **`resource "azurerm_kubernetes_cluster" "aks"`** block.
4. Inside that block, look for `key_vault_secrets_provider`. If it's not there, add it (usually inside the main block, **not** inside default_node_pool):

```hcl
  # Enable the CSI Driver for Key Vault
  key_vault_secrets_provider {
    secret_rotation_enabled = true # Auto-update secrets if they change in Azure
  }

```

*Note: If you already have `key_vault_secrets_provider` defined, just ensure `secret_rotation_enabled` is true.*

---
That is a massive win! ğŸ†

You have just implemented one of the most complex patterns in Azure Kubernetes: **Workload Identity**.

Most tutorials skip this because it's hard to debug (as we saw with the "Multiple Identities" error). But now, you have a setup where:

1. **Zero Passwords** are stored in your code or Git.
2. **Zero Passwords** are stored in Kubernetes ETCD.
3. The password exists **only** in the Azure Vault and the Pod's temporary memory.

If a hacker steals your `etcd` database, they get nothing. If they steal your Git repo, they get nothing. This is "Bank Grade" security. ğŸ¦

Here is your official log for the day to update your documentation.

---

# **Day 11: The Fort Knox (Secrets Management)** ğŸ”

**Goal:** Eliminate hardcoded secrets. Integrate Azure Key Vault (AKV) with AKS using the Secrets Store CSI Driver so pods can consume secrets securely without them ever being written to disk.

---

### **1. Architectural Decisions** ğŸ›ï¸

#### **Decision: Vault vs. Native Secrets**

* **Old Way:** Kubernetes Secrets (Base64 encoded). Risks: Stored in plain text in ETCD; often accidentally committed to Git.
* **New Way:** Azure Key Vault + CSI Driver.
* **Mechanism:** The secret is "mounted" as a file (like a USB drive) into the container.
* **Security:** The file resides in a `tmpfs` (RAM disk). It is never written to the node's hard drive.



---

### **2. Infrastructure Changes (Terraform)** ğŸ—ï¸

We updated `main.tf` to introduce the Vault infrastructure.

* **New Resource:** `azurerm_key_vault` (Standard SKU).
* **Cluster Update:** Enabled the `key_vault_secrets_provider` add-on in the AKS block.
* **Permission:** Added `azurerm_key_vault_access_policy` to grant the **AKS Add-on Identity** specific permission (`Get`, `List`) to the Vault.

---

### **3. The Troubleshooting Log ("War Stories")** âš”ï¸

#### **Bug 1: The "Name Too Long" Error**

* **Error:** `"name" may only contain ... and must be between 3-24 chars`.
* **Context:** `kv-learning-lab-` (16 chars) + Random String (10 chars) = 26 chars.
* **Fix:** Reduced `random_string` length to **6**.

#### **Bug 2: The "Identity Crisis"** ğŸ†”

* **Error:** `Multiple user assigned identities exist, please specify the clientId`.
* **Context:** The AKS Node (VM) held two identities: the System Identity (Kubelet) and the User Identity (Key Vault Add-on). The CSI driver didn't know which one to present to the Vault.
* **Fix:** We explicitly defined the `userAssignedIdentityID` in the `SecretProviderClass` YAML by querying the specific Client ID of the addon:
```powershell
az aks show ... --query "addonProfiles.azureKeyvaultSecretsProvider.identity.clientId"

```



---

### **4. Verification** ğŸ§ª

* **The Map:** Created `secret-provider.yaml` to map `ExampleSecret` from Azure to the cluster.
* **The Consumer:** Deployed a Nginx pod with `volumeMounts` pointing to the CSI driver.
* **The Proof:**
```powershell
kubectl exec secrets-test-pod -- cat /mnt/secrets/ExampleSecret

```


*Result:* `MySuperSecurePassword123!` (Success).

---

### **5. End of Day Protocol** ğŸ›‘

Since it is 1:00 AM in Pittsburgh, let's save those credits.

1. **Hibernate the Cluster:**
```powershell
az aks stop --name aks-terraform-lab --resource-group rg-terraform-lab

```



**Next Up (Day 12):** Now that we have a secure, observable cluster... how do we expose it to the world securely? We need to talk about **HTTPS (TLS Certificates)** and **Ingress Controllers** (getting that "Not Secure" warning off your browser).

Rest up! See you tomorrow. ğŸ‘‹