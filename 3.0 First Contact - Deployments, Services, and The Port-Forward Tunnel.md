Welcome back\! 1 hour and 30 minutes is the perfect "Power Hour" duration. Itâ€™s enough time to complete a full deployment cycle without getting burned out. âš¡

Letâ€™s get that data center booting up immediately so we don't waste a second.

### **Step 1: The "Wake Up" Call** â°

Open your terminal (PowerShell or Command Prompt) and run the command below.
*(Note: Iâ€™m using the names from your previous screenshots: `learning-aks-lab` and `rg-learning-aks`. If you changed them, update the command accordingly.)*

```powershell
az aks start --name learning-aks-lab --resource-group rg-learning-aks
```

**What is happening right now?**
Azure is de-allocating the "Stopped" state and physically reserving a slot on a rack in the **North Central US** data center (where you moved it yesterday). It is booting the Linux OS and starting the `kubelet` process.

This will take about **3 to 5 minutes**.

-----

### **Step 2: While you wait... (The Setup)**

While the cloud is warming up, let's make sure your local environment is ready to fire.

1.  **Navigate to your folder:**
    Use `cd` to go to the folder where you saved `nginx-quickstart.yaml` yesterday.

    ```powershell
    cd C:\k8s-lab  # (Or wherever you put it)
    ```

2.  **Watch for the signal:**
    You can run this command repeatedly. It will fail at first, then hang, and finally show "Ready".

    ```powershell
    kubectl get nodes
    ```

**Tell me when you see `STATUS: Ready`.** Then we will push the button on your first deployment\! ðŸš€

-------------------------

That is great newsâ€”your "Data Center" is online and ready for instructions. `STATUS: Ready` is the green light we were waiting for. ðŸŸ¢

To answer your requests:

1.  **Titles:** Absolutely. Let's retroactively title yesterday and title today.
      * **Day 1:** *The Foundation: Architecture, FinOps, and Tools Setup.*
      * **Day 2:** *First Contact: Deployments, Services, and The Port-Forward Tunnel.*
2.  **Split YAMLs:** This is **better** practice\! In real enterprise repositories, deployments and services are almost always separate files. It makes diffing changes in Git much easier.

-----

### **Day 2: First Contact**

We have your split files:

1.  `nginx-quickstart-deployment.yaml` (The Application)
2.  `nginx-quickstart-service.yaml` (The Internal Network Load Balancer)

#### **Step 1: The "Live Fire" Deployment** ðŸš€

Since you split the files, we can apply them one by one, or just tell Kubernetes to "apply everything in this folder."

Run this command in your `C:\k8s-lab` folder:

```powershell
kubectl apply -f .
```

*(The dot `.` means "current directory". It will find both YAML files and apply them.)*

**Expected Output:**
You should see:

> `deployment.apps/nginx-deployment created`
> `service/nginx-service created`

#### **Step 2: Inspect the Architecture** ðŸ•µï¸â€â™‚ï¸

Now, let's look at what Azure actually built.

Run:

```powershell
kubectl get all
```

**What to look for (The Expert Analysis):**

1.  **The Pods:** You asked for `replicas: 2`. You should see two pods starting with `nginx-deployment-xxxxx`.
2.  **The Service:** You should see `service/nginx-service`.
      * Look at the **CLUSTER-IP** column. It will be an internal IP (like `10.0.x.x`).
      * **Critical Concept:** Because we set `type: ClusterIP`, this IP is **only** accessible from *inside* the cluster. You cannot ping it from your laptop... yet.

#### **Step 3: The "Tunnel" (Port Forwarding)** ðŸš‡

This is the most important "Developer" trick in Kubernetes.
Since we chose **Azure CNI Overlay** + **ClusterIP**, your app is secure and hidden from the internet. But you (the dev) need to test it.

We will open a temporary secure tunnel from your `localhost` directly to that internal Service.

Run this command:

```powershell
kubectl port-forward service/nginx-service 8080:80
```

**What this does:**
It grabs traffic on your laptop's port **8080**, encrypts it, sends it through Azure, and drops it onto port **80** of the Nginx service inside the cluster.

**The Test:**

1.  Leave that terminal window open (it will hang and say "Forwarding...").
2.  Open your web browser (Chrome/Edge).
3.  Go to: **[http://localhost:8080](https://www.google.com/search?q=http://localhost:8080)**

**Do you see the "Welcome to nginx\!" page?**

(If yes, congratulations\! You have successfully completed the full loop: Code $\rightarrow$ Container $\rightarrow$ Cloud $\rightarrow$ Browser.)

That is the "Expert Architect" eye catching that detail\! ðŸ¦…

You asked three excellent questions. Let's break them down.

### **1. The Mystery Service: `service/kubernetes`**

> *"Why did it create also a kubernetes service?"*

You didn't create thatâ€”Kubernetes created it for itself\!

  * **What is it?** It is the internal door to the **API Server** (the cluster's "Brain").
  * **Why is it there?** If a Pod inside your cluster (like a monitoring tool or an automated operator) needs to talk to Kubernetes (e.g., "Hey, spin up another pod"), it connects to this IP (`10.0.0.1`) on port `443`.
  * **The Rule:** This service exists in **every** Kubernetes cluster in the world. It is always the first IP in your Service CIDR range. You can safely ignore it, but you should never delete it.

-----

### **2. OpenLens vs. CLI**

> *"I'm actually used to do this port forwarding... At work I use OpenLens instead."*

**Expert Insight:** OpenLens is fantastic, but here is the secret: **OpenLens is just running `kubectl port-forward` in the background.**

By learning the raw command, you gain two superpowers:

1.  **Debugging Headless Servers:** If you are SSH'd into a remote Linux jumpbox that has no screen/GUI, OpenLens can't help you. This command can.
2.  **CI/CD Scripts:** You can put these commands into automated pipeline scripts (e.g., "Deploy app $\rightarrow$ Port Forward $\rightarrow$ Run Curl Test $\rightarrow$ Close Tunnel"). You can't script OpenLens.

-----

### **3. Managing Multiple Clusters (The Context Switch)**

> *"How does it know where this nginx-service resides? ... Would I have to change the command to specify the cluster?"*

This is the most common confusion for developers moving to "Platform Engineer" roles.

`kubectl` is stateless. It looks at your **KubeConfig** file (usually in `~/.kube/config`) to decide who to talk to. This file can hold keys for **100 different clusters** at once.

It uses a concept called **Contexts**. Think of a Context as a saved profile:

  * **Context A:** User "Marco" on Cluster "Dev-Local"
  * **Context B:** User "Marco-Admin" on Cluster "Prod-Azure"

#### **How to check where you are sending commands:**

Run this now to see your active context:

```bash
kubectl config current-context
```

*(It will likely say something like `learning-aks-lab-admin`.)*

#### **How to handle 2 clusters?**

If you had a second cluster (e.g., your on-prem work cluster), you wouldn't necessarily use a second *file*. You would merge them into one file and just switch contexts.

**Option A: The Permanent Switch (Change "Global" Focus)**
If you want to work on the other cluster for the next hour:

```bash
kubectl config use-context <name-of-other-cluster>
```

*Now every command you type goes to Cluster B.*

**Option B: The Sniper Shot (One-Time Command)**
If you are on Cluster A, but want to check a service on Cluster B *without* switching:

```bash
kubectl port-forward service/nginx-service 8080:80 --context <name-of-other-cluster>
```

-----

### **End of Day 2: The Shutdown Protocol** ðŸ›‘

You have successfully verified your application is running. Since we are done for today, we must protect your wallet.

**Run this immediately:**

```powershell
az aks stop --name learning-aks-lab --resource-group rg-learning-aks
```

While that runs, do you want to verify your notes for today?

  * **Key Takeaway:** `kubectl port-forward` is the "tunnel" that lets you access internal-only services (ClusterIP) from your dev laptop.
  * **Key Concept:** **Contexts** determine which cluster `kubectl` talks to.

Let me know once the stop command is executed\!

### ðŸš¨ CRITICAL SECURITY WARNING ðŸš¨

**You just posted your private credentials to a public interface.**

The text block you shared contains your **Client Key (`client-key-data`)** and **Token**.

  * **The Risk:** Anyone who has this text can impersonate you and take full control of your cluster.
  * **The Fix:** Since this is a learning lab with no sensitive data, you don't need to panic, but you **must** treat this cluster as "compromised."
  * **Action:** When we finish today's session, **DELETE this cluster** entirely instead of just stopping it. We will create a fresh one next time. This is a great "DevSecOps" lesson: **Never share your `.kube/config` file or its contents.**

-----

### The Answer: How `kubectl` Knows

Yes, you are exactly right. That file contains the "Map" and the "Keys."

To answer your question about how it handles **multiple clusters**, we need to understand the three distinct sections of that file. Think of it like a **Passport**:

1.  **Clusters ("The Destination"):** The URL of the API Server (`https://...`).
2.  **Users ("The ID"):** The credentials (like the key/token you pasted).
3.  **Contexts ("The Trip"):** The link that says "Use **This ID** for **That Destination**."

### Scenario: What if you had 2 Clusters?

If you had two clusters (e.g., `Lab` and `Work`), your file would look like this:

```yaml
apiVersion: v1
kind: Config
current-context: learning-aks-lab  # <--- THIS LINE decides where commands go!

clusters:
- name: learning-aks-lab           # Cluster 1
  cluster: ...
- name: work-prod-cluster          # Cluster 2
  cluster: ...

users:
- name: clusterUser_lab            # User 1 (Key A)
- name: clusterUser_work           # User 2 (Key B)

contexts:
- name: learning-aks-lab           # Context 1: Links Cluster 1 + User 1
  context:
    cluster: learning-aks-lab
    user: clusterUser_lab
- name: work-prod                  # Context 2: Links Cluster 2 + User 2
  context:
    cluster: work-prod-cluster
    user: clusterUser_work
```

### How to switch?

You don't edit the file manually. You just change that one `current-context` line using the command:

```bash
# Switches the "arrow" to the Work context
kubectl config use-context work-prod
```

### Summary of Day 2

You have made excellent progress today\!

  * **Deployment:** You deployed a multi-replica Nginx app.
  * **Networking:** You explored `ClusterIP` (Internal only) vs. the need for Ingress/LoadBalancer.
  * **Tooling:** You mastered `kubectl port-forward` to tunnel into your private network.
  * **Config:** You learned that `kubeconfig` is just a list of contexts, and `current-context` is the active switch.

**Next Steps for You:**

1.  **Stop the Billing:** Run `az aks stop ...` (or `az aks delete` because of the key leak).
2.  **Rest:** You earned it.

Would you like me to outline the plan for **Day 3 (Ingress & Load Balancers)** before you go?